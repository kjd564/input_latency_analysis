<!DOCTYPE html>
<!--
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/unit.html">
<link rel="import" href="/tracing/extras/chrome/cc/input_latency_async_slice.html">
<link rel="import" href="/tracing/model/async_slice_group.html">
<link rel="import" href="/tracing/model/event_set.html">
<link rel="import" href="/tracing/model/helpers/chrome_model_helper.html">
<link rel="import" href="/tracing/value/histogram.html">

<script>
'use strict';

tr.exportTo('pi.m', function() {

  var LATENCY_EVENT = "InputLatency::GestureScrollUpdate";  // Latency event to be analyzed
  var LATENCY_DURATION_THRESHOLD = 100;                     // How long the latency event must take in ms
  var UNINTERESTING_EVENTS = [                              // Events to be ignored in the top down approach
    "ChannelMojo::OnMessageReceived",
    "Event.Pipeline",
    "EventHandler::HitTestResultAtLocation",
    "FunctionCall",
    "LatencyInfo.Flow",
    "LocalFrameView::RunStyleAndLayoutLifecyclePhases",
    "LocalFrameView::updateStyleAndLayoutIfNeededRecursive",
    "LongTask",
    "MessageLoop::RunTask",
    "none",
    "PendingScript::ExecuteScriptBlock",
    "RenderWidgetInputHandler::OnHandleInputEvent",
    "RunTask",
    "ScheduledAction::execute",
    "SequenceManagerImpl::TakeTask",
    "TaskGraphRunner::RunTask",
    "TaskScheduler RunTask",
    "TaskQueueManager::DoWork",
    "TaskQueueManager::ProcessTaskFromWorkQueue",
    "TaskQueueManager::RunTask",
    "ThreadController::Task",
    "ThreadControllerImpl::DoWork",
    "ThreadControllerImpl::RunTask",
    "ThreadProxy::BeginMainFrame",
    "unknown interface",
    "WebViewImpl::beginFrame",
    "WebViewImpl::handleInputEvent",
  ];

  function inputLatencyMapper(result, model) {
    var results = [];

    const modelHelper = model.getOrCreateHelper(tr.model.helpers.ChromeModelHelper);
    const latencyEvents = getInputLatencyEvents(modelHelper.browserHelper);

    for (const latency of latencyEvents) {
      var data = latency.args.data;
      var id = (latency.id.startsWith(':ptr:') ? latency.id.slice(5) : latency.id);

      // Latency duration will be the time when the latency event is dispatched to the renderer to when the rendering is scheduled
      var latency_start = (data) ? model.convertTimestampToModelTime(
                                   "traceEventClock",data["INPUT_EVENT_LATENCY_BEGIN_RWH_COMPONENT"].time) : 0;
      var latency_end = (data && data.hasOwnProperty("INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_MAIN_COMPONENT")) ?
                                       model.convertTimestampToModelTime("traceEventClock", 
                                       data["INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_MAIN_COMPONENT"].time) : 0;
      var latency_duration = latency_end - latency_start;
      var latency_mid = (data && data.hasOwnProperty("INPUT_EVENT_LATENCY_RENDERER_MAIN_COMPONENT")) ?
                         model.convertTimestampToModelTime("traceEventClock", data["INPUT_EVENT_LATENCY_RENDERER_MAIN_COMPONENT"].time) : 0

      // Only look at completed latency events that are above the duration threshold
      if (latency.inputLatency && latency_duration >= LATENCY_DURATION_THRESHOLD && latency_mid != 0) {
        latency.id = id;

        // Get the top level events associated with this latency event
        var model_indices = latency.startThread.parent.model.modelIndices;
        var flow_events = model_indices.getFlowEventsWithId(id);
        var associated_events = latency.associatedEvents;

        // Get the renderer process id from the event that handles the input
        var renderer_process, latency_middl;
        for (const event of associated_events) {
          if (event.hasOwnProperty('parentContainer') && event.title === 'RenderWidgetInputHandler::OnHandleInputEvent')
            renderer_process = event.parentContainer.getProcess().pid;
        }

        // Get the top level slices of events happening on the renderer during the latency
        var range_of_interest = new tr.b.math.Range.fromExplicitRange(latency_start, latency_end);
        var renderer_events = getRendererEventsInRange(modelHelper.browserHelper, renderer_process, range_of_interest);
        var top_level = getTopLevelSlices(renderer_events, latency_start, latency_end);
        
        // Bottom-Up approach
        //
        // For each event happening during the latency, take the trueDuration of the event
        // where the trueDuration is the duration of the event minus the durations of its 
        // children. All events are split into a queuing and handling portion at the latency
        // mid point.
        var expanded_events = [];
        expandTopLevel(top_level, expanded_events, latency_start, latency_end);

        var queue = [];
        var handle = [];
        var queue_active = 0;
        var handle_active = 0;
        for (const event of expanded_events) {
          // Event is part of the queue portion
          if (event.end < latency_mid) {
            queue.push(event);
	    queue_active += event.trueDuration;
          // Event is part of the handle portion
          } else if (event.start >= latency_mid) {
            handle.push(event);
            handle_active += event.trueDuration;
          // Event is split between the two
          } else {
            var queue_portion = Object.assign({}, event);
            var handle_portion = Object.assign({}, event);
            
            queue_portion.end = latency_mid;
            queue_portion.trueDuration= getTrueDuration(queue_portion, latency_start, latency_mid);
            handle_portion.start = latency_mid;
            handle_portion.trueDuration = getTrueDuration(handle_portion, latency_mid, latency_end);

            queue.push(queue_portion);
            handle.push(handle_portion);
            queue_active += queue_portion.trueDuration; 
            handle_active += handle_portion.trueDuration
          }
        }

        // Time where nothing is happening on the renderer is considered idle time
        var queue_renderer_idle = (latency_mid - latency_start) - queue_active;
        queue.push({"title":"rendererIdle", "trueDuration":queue_renderer_idle});
        queue_active +=queue_renderer_idle;
        var handle_renderer_idle = (latency_end - latency_mid) - handle_active;
        handle.push({"title":"rendererIdle", "trueDuration":handle_renderer_idle});
        handle_active += handle_renderer_idle;

        // Top-Down approach
        //
        // Starting at the top level slices, traverse down the slice
        // stack until finding an event that is not on the uninteresting
        // event list. 
        var expanded_events_uninteresting = [];
        expandTopLevelUninteresting(top_level, expanded_events_uninteresting, latency_start, latency_end, latency_mid);

        var queue_uninteresting = [];
        var handle_uninteresting = [];
        var handle_active_uninteresting = 0;
        var queue_active_uninteresting = 0;
        for (const event of expanded_events_uninteresting) {
          // Event is part of the queue portion
          if (event.end < latency_mid) {
            queue_uninteresting.push(event);
            queue_active_uninteresting += event.duration;
          // Event is part of the handle portion
          } else if (event.start >= latency_mid) {
            handle_uninteresting.push(event);
            handle_active_uninteresting += event.duration;
          // Event is split between the two
          } else {
            var queue_portion = Object.assign({}, event);
            var handle_portion = Object.assign({}, event);

            queue_portion.end = latency_mid;
            handle_portion.start = latency_mid;
            queue_portion.duration = latency_mid - queue_portion.start;
            handle_portion.duration = handle_portion.end - latency_mid;

            queue_uninteresting.push(queue_portion);
            handle_uninteresting.push(handle_portion);
            queue_active_uninteresting += queue_portion.duration;
            handle_active_uninteresting += handle_portion.duration
          }
        }

        // Add rendererIdle times, which are the same as the Bottom-Up approach
        queue_uninteresting.push({"title":"rendererIdle", "duration":queue_renderer_idle});
        handle_uninteresting.push({"title":"rendererIdle", "duration":handle_renderer_idle});
        queue_active_uninteresting += queue_renderer_idle;
        handle_active_uninteresting += handle_renderer_idle; 

        // Calculate uninteresting time, which is all unaccounted for time (total time minus the 
        // active time, which are the events we consider interesting plus the time spent idle, what
        // remains is the time spent in uninteresting tasks) 
        var queue_uninteresting_time = (latency_mid - latency_start) - queue_active_uninteresting;
        queue_uninteresting.push({"title":"uninteresting", "duration":queue_uninteresting_time});        
        queue_active_uninteresting += queue_uninteresting_time;
        var handle_uninteresting_time = (latency_end - latency_mid) - handle_active_uninteresting;
        handle_uninteresting.push({"title":"uninteresting", "duration":handle_uninteresting_time});
        handle_active_uninteresting += handle_uninteresting_time;

	results.push({"Latency Duration":latency_duration, "Queue Events Bottom-Up":mergeSameNameEvents(queue), 
                      "Handling Events Bottom-Up":mergeSameNameEvents(handle), "Bottom-Up Event Sum":queue_active + handle_active, 
                      "Queue Events Top-Down":mergeSameNameEvents(queue_uninteresting, "duration"), 
                      "Handling Events Top-Down":mergeSameNameEvents(handle_uninteresting, "duration"), 
                      "Top-Down Event Sum":queue_active_uninteresting + handle_active_uninteresting});
      }
    }
    result.addPair("Latencies", results);
  }

  tr.mre.FunctionRegistry.register(inputLatencyMapper);

  return {
    inputLatencyMapper,
  };

  function getInputLatencyEvents(browserHelper) {
    const isInputLatencyEvent = e => e.title === LATENCY_EVENT;
    return browserHelper.getAllAsyncSlicesMatching(isInputLatencyEvent);
  }

  function getRendererEventsInRange(browserHelper, rendererID, range_of_interest) {
    return browserHelper.getAllAsyncSlicesMatching(function(slice) {
      return (slice.parentContainer.getProcess().pid === rendererID &&
              slice.parentContainer.name === "CrRendererMain" && 
              slice.category != "disabled-by-default-renderer.scheduler" &&
              slice.category != "renderer.scheduler" &&
              slice.category != "blink.animations,devtools.timeline,benchmark,rail" &&
              slice.start >= range_of_interest.min &&
              slice.end <= range_of_interest.max)
    });
  }

  // Given a set of slices, get all the top level slices within time bounds
  function getTopLevelSlices(slices, start, end) {
    var top_level = [];
    for (const slice of slices) {
      // If the top level slice is not already in the top level slices list
      if (typeof slice.mostTopLevelSlice !== "undefined"
          && top_level.indexOf(slice.mostTopLevelSlice) === -1) {
        top_level.push(slice.mostTopLevelSlice);
      }
    }
    return top_level;
  }

  // Expand top level slices by getting true durations for all of the children slices recursively
  function expandTopLevel(top_level_slices, expanded, start, end) {
    for (const top_slice of top_level_slices) {
      if (top_slice.start < end && top_slice.end > start) {
        expanded.push({"title":top_slice.title, "duration":top_slice.duration, "trueDuration":getTrueDuration(top_slice, start, end), 
                       "start":top_slice.start, "end":top_slice.start + top_slice.duration, "subSlices":top_slice.subSlices});
      }
      expandTopLevel(top_slice.subSlices, expanded, start, end);
    }
  }

  // Expand top level slices by finding interesting slices and reporting their durations
  function expandTopLevelUninteresting(top_level_slices, expanded, start, end, mid) {
    for (const top_slice of top_level_slices) {
      addInterestingEvents(top_slice, expanded, start, end, mid);
    }
  }

  // Add event to a dictionary that is not on the uninteresting list and is bounded by the latency duration
  function addInterestingEvents(top_slice, expanded, start, end, mid) {
    if (isInterestingEvent(top_slice)) {
      var s = top_slice.start;
      var e = top_slice.start + top_slice.duration;
      if (s < end && e > start) {
        if (s < start) { s = start; };
        if (e > end) { e = end; };
        expanded.push({"title":top_slice.title, "duration":e - s, "start":s, "end":e, "subSlices":top_slice.subSlices});
      }
    } else {
      for (const child of top_slice.subSlices) {
        addInterestingEvents(child, expanded, start, end, mid);
      }
      return;
    }
  }

  function isInterestingEvent(event) {
    for (const title of UNINTERESTING_EVENTS) {
      if (event.title === title)
        return false;
    }
    return true;
  }

  // Get the duration of a latency event within the bounds of the latency
  // minus the duration of its children
  function getTrueDuration(slice, lower_limit, upper_limit) {
     var children_duration = 0;
     for (const child of slice.subSlices) {
       var s = child.start;
       var e = child.end;
       // Child is not within the bounds of the latency 
       if (s > upper_limit || e < lower_limit) {
         children_duration += 0;
       } else {
         if (s < lower_limit) { s = lower_limit; };
         if (e > upper_limit) { e = upper_limit; };
         var dur = ((e - s) > 0) ? e - s : 0;
         children_duration += dur;
       }
     }
     var slice_s = (slice.start < lower_limit) ? lower_limit : slice.start;
     var slice_e = (slice.start + slice.duration > upper_limit) ? upper_limit : slice.start + slice.duration;
     return (slice_e - slice_s) - children_duration;
  }

  // Sum durations of the same name events for a latency
  function mergeSameNameEvents(events, duration = "trueDuration") {
    var merged = {};
    for (const event of events) {
      if (merged.hasOwnProperty(event.title)) {
        merged[event.title] += event[duration];
      } else {
        merged[event.title] = event[duration];
      }
    }
    return merged;
  }
});
</script>
